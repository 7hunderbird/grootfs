#!/bin/bash -e
source hack/utils.sh

usage() {
  colour=$1
  print_message "Usage:" $colour
  print_message "deps --- update all dependencies" $colour
  print_message "deps -a <url> --- add a new dependency" $colour
  print_message "deps -d <url> --- remove a dependency" $colour
  print_message "deps -h --- print help menu" $colour
}

update_deps() {
  check_clean_status
  check_docker_sha
  update_glide
  remove_existing_submodules
  glide install
  add_required_submodules
  test_warning
}

add_dep() {
  dep=$1

  check_clean_status
  glide get $dep
  update_and_commit Add $dep
}

remove_dep() {
  dep=$1

  check_clean_status
  update_glide_yaml $dep
  update_and_commit Remove $dep
}

check_glide_version() {
  gv=$(glide --version | awk '{print $3}')
  if [ $gv != "0.11.1" ]; then
    print_message "YOUR GLIDE VERSION IS $gv" $RED
    print_message "THIS SCRIPT REQUIRES GLIDE 0.11.1" $RED
    if [[ $(uname) == "Darwin" ]]; then
      print_message "SWITCHING NOW..." $RED
      brew switch glide 0.11.1 &> /dev/null
    else
      print_message "GO FIX IT" $RED
      exit 1
    fi
  fi
  print_message "GLIDE VERSION OK" $GREEN
}

check_clean_status() {
  print_message "CHECKING IF STATUS IS CLEAN" $GREEN
  if ! [ -z "$(git status --porcelain)" ]; then
    print_message "STATUS NOT CLEAN, COMMIT FIRST" $RED
    exit 1
  else
    print_message "STATUS CLEAN, CARRYING ON..." $GREEN
  fi
}

update_and_commit() {
  action=$1
  dep=$2
  git add -A
  git duet-commit -m "$action dependency $dep" &> /dev/null
  update_deps
  git add -A
  git duet-commit --amend
}

update_glide_yaml() {
  print_message "UPDATING GLIDE.YAML" $GREEN

  dep=$1
  file="glide.yaml"
  r_script="data = YAML::load_file('$file'); \
    del = data['import'].each.find{ |k, _| k['package'] == '$dep' }; \
    data['import'].delete(del); \
    File.open('$file', 'w') { |f| YAML.dump(data, f) }"
  ruby -ryaml -e "$r_script"

  print_message "DONE" $GREEN
}

check_docker_sha() {
  print_message "CHECKING DOCKER SHA" $GREEN
  current_commit_sha=$(grep -A 1 'docker/docker' glide.yaml | awk '/version/ {print $2}')
  echo "The current commit sha for github.com/docker/docker is: ${current_commit_sha}"
  read -n 1 -p "Is this correct? (y/n) " choice
  echo
  case $choice in
    "y")
      print_message "GROOT TO GO!" $GREEN
      ;;
    "n")
      print_message "You should probably sort that out..." $RED
      exit 1
      ;;
    *)
      print_message "LEARN HOW TO TYPE" $RED
      exit 1
      ;;
  esac
}

update_glide() {
  print_message "UPDATING GLIDE DEPENDENCIES" $GREEN
  glide update
  print_message "DONE" $GREEN
}

remove_existing_submodules() {
  if [ -d vendor/ ]; then
    print_message "REMOVING EXISTING SUBMODULES FROM VENDOR" $GREEN
    rm -rf vendor/
    git rm -rf vendor/ &> /dev/null
    git submodule deinit --all -f
    print_message "DONE" $GREEN
  fi
}

convert_url() {
  repoPath=$1
  url_conversion_rules=("s/code.cloudfoundry.org/github.com\/cloudfoundry/" "s/golang.org\/x/go.googlesource.com/")

  url="https://"$(echo $repoPath | sed -e 's/.\/vendor\///')
  for rule in ${url_conversion_rules[@]}; do
    url=$(echo $url | sed $rule)
  done

  echo $url
}

add_submodule() {
  path=$1
  repoPath=$(echo $path | sed -e 's/\/.git//')
  url=$(convert_url $repoPath)

  git submodule add $url $repoPath &> /dev/null
}

add_required_submodules() {
  print_message "ADDING REQUIRED SUBMODULES" $GREEN
  requires_submodules=$(find . -name ".git" -mindepth 2)
  for submodule in ${requires_submodules[@]}; do
    print_message "ADDING SUBMODULE $submodule" $GREEN

    add_submodule $submodule
  done
  print_message "DONE" $GREEN
}

test_warning() {
  print_message "Dependencies updated." $RED
  print_message "TEST NOW." $RED
}

check_glide_version

while getopts "a:d:h" OPTION
do
  case $OPTION in
    a)
      add_dep $OPTARG
      exit
      ;;
    d)
      remove_dep $OPTARG
      exit
      ;;
    h)
      usage $GREEN
      exit
      ;;
    *)
      usage $RED
      exit
      ;;
  esac
done

if [ -z $OPTARG ]; then
  update_deps
fi
